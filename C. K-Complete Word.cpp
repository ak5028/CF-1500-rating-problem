//AKJ
#include<bits/stdc++.h>
using namespace std;
#define pb push_back
#define ff first
#define ss second
#define all(x) (x).begin(),(x).end()
//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>
typedef long long ll;
//typedef __gnu_pbds::tree<int, __gnu_pbds::null_type, less<int>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ordered_set;
//ordered_set st;

const int maxn=200007;

int n,k,ans=0;
int cnt[maxn][26];
string s;

int differ(int u,int v){
    int ret=0,mx=0;
    for (int j=0;j<26;++j){
        ret+=cnt[u][j]+cnt[v][j];
        mx=max(mx,cnt[u][j]+cnt[v][j]);
    }
    return ret-mx;
}

int main(){
    int t;
    cin>>t;
    while (t--){
        cin>>n>>k>>s;

        //One should notice that word s of length n is k-complete if and only if there exists a palindrome t
        //of length k such that s can be generated by several concatenations of t.So in the final string all characters at positions 
        //i, k−i+1, k+i, 2k−i+1, 2k+i, 3k−i+1, …for all 1≤i≤k should all be equal. This helps us to solve the problem independently for each i
        //To minimize the required number of changes, you should make all the letters equal to the one which appears at these positions the most initially.
        //Calculate that maximum number of appearances and sum up over all i.Be careful with an odd k
        //because the letter in the center of each block has a different formula.
        
        for (int i=0;i<k;++i){
            for (int j=0;j<26;++j){
                cnt[i][j]=0;
            }
        }
        for (int i=0;i<n;++i){
            cnt[i%k][s[i]-'a']++;
        }
        int ans=0;
        for (int i=0;i<k;++i){
            ans+=differ(i,k-1-i);
        }
        cout<<ans/2<<"\n";
    }
    return 0;
}
